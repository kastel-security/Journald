diff --git a/src/libsystemd/sd-journal/journal-verify.c b/src/libsystemd/sd-journal/journal-verify.c
index ad4039dee0..e3a26a8ae4 100644
--- a/src/libsystemd/sd-journal/journal-verify.c
+++ b/src/libsystemd/sd-journal/journal-verify.c
@@ -492,6 +492,9 @@ static int verify_data(
 
                 m = journal_file_entry_array_n_items(f, o);
                 for (j = 0; i < n && j < m; i++, j++) {
+                        Object *o_entry;
+                        uint64_t n_items, k;
+                        int found = 0;
 
                         q = journal_file_entry_array_item(f, o, j);
                         if (q <= last) {
@@ -512,6 +515,23 @@ static int verify_data(
                                 error(q, "Entry object doesn't exist in the main entry array");
                                 return -EBADMSG;
                         }
+                        r = journal_file_move_to_object(f, OBJECT_ENTRY, q, &o_entry);
+                        if (r < 0)
+                                return r;
+                        n_items = journal_file_entry_n_items(f, o_entry);
+                        for (k = 0; k < n_items; k++) {
+                                uint64_t s;
+
+                                s = journal_file_entry_item_object_offset(f, o_entry, k);
+                                if ( s == p ) {
+                                        found = 1;
+                                        break;
+                                }
+                        }
+                        if (!found) {
+                                error(q, "Data links back to wrong entry.");
+                                return -EBADMSG;
+                        }
 
                         /* Pointer might have moved, reposition */
                         r = journal_file_move_to_object(f, OBJECT_ENTRY_ARRAY, a, &o);
@@ -525,6 +545,105 @@ static int verify_data(
         return 0;
 }
 
+static int verify_field_hash_table(
+                JournalFile *f,
+                MMapFileDescriptor *cache_field_fd, uint64_t n_fields) {
+        uint64_t n, i;
+        uint64_t hash_table_count = 0;
+        int r;
+
+        assert(f);
+        assert(cache_field_fd);
+
+        n = le64toh(f->header->field_hash_table_size) / sizeof(HashItem);
+        if (n <= 0)
+                return 0;
+
+        r = journal_file_map_field_hash_table(f);
+        if (r < 0)
+                return log_error_errno(r, "Failed to map field hash table: %m");
+
+        for (i = 0; i < n; i++) {
+                uint64_t last = 0, p;
+
+                p = le64toh(f->field_hash_table[i].head_hash_offset);
+                while (p != 0) {
+                        Object *o;
+                        uint64_t next;
+                        uint64_t payload_len;
+                        uint64_t p_data;
+                        char *name = NULL;
+
+                        hash_table_count++;
+                        if (!contains_uint64(cache_field_fd, n_fields, p)) {
+                                error(p, "Invalid field object at hash entry %"PRIu64, p);
+                                error(p, "Invalid field object at hash entry %"PRIu64" of %"PRIu64, i, n);
+                                return -EBADMSG;
+                        }
+                        r = journal_file_move_to_object(f, OBJECT_FIELD, p, &o);
+                        if (r < 0)
+                                return r;
+
+                        payload_len = le64toh(o->object.size) - offsetof(Object, field.payload);
+                        name = (char *) &o->field.payload;
+                        if (memchr(name, '=', payload_len) != NULL) {
+                                error(p,
+                                      "Field name contains '='");
+                                return -EBADMSG;
+                        }
+
+                        next = le64toh(o->field.next_hash_offset);
+                        if (next != 0 && next <= p) {
+                                error(p, "Hash chain has a cycle in hash entry %"PRIu64" of %"PRIu64, i, n);
+                                return -EBADMSG;
+                        }
+
+                        if (le64toh(o->data.hash) % n != i) {
+                                error(p, "Hash value mismatch in hash entry %"PRIu64" of %"PRIu64, i, n);
+                                return -EBADMSG;
+                        }
+
+                        p_data = le64toh(o->field.head_data_offset);
+                        while (p_data != 0) {
+                                Object *data;
+                                char *data_payload = NULL;
+                                size_t data_len;
+
+                                r = journal_file_move_to_object(f, OBJECT_DATA, p_data, &data);
+                                if (r < 0)
+                                        return r;
+                                r = journal_file_data_payload(f, NULL, p_data, NULL, 0, 0, (void **) &data_payload, &data_len);
+                                if (r < 0)
+                                        return r;
+                                if (data_payload == NULL) {
+                                        return -EBADMSG;
+                                }
+                                if (data_len <= payload_len || strncmp(data_payload, name, payload_len) != 0 || data_payload[payload_len] != '=') {
+                                        error(p_data, "Data does not start with correct field");
+                                        return -EBADMSG;
+                                }
+
+                                p_data = le64toh(data->data.next_hash_offset);
+                        }
+
+                        last = p;
+                        p = next;
+                }
+                if (last != le64toh(f->field_hash_table[i].tail_hash_offset)) {
+                        error(p,
+                              "Tail hash pointer mismatch in hash table (%"PRIu64" != %"PRIu64")",
+                              last,
+                              le64toh(f->field_hash_table[i].tail_hash_offset));
+                        return -EBADMSG;
+                }
+        }
+        if (hash_table_count != n_fields) {
+                error(offsetof(Header, n_objects), "Field hash table count mismatch: %"PRIu64" != %"PRIu64, hash_table_count, n_fields);
+                return -EBADMSG;
+        }
+        return 0;
+}
+
 static int verify_data_hash_table(
                 JournalFile *f,
                 MMapFileDescriptor *cache_data_fd, uint64_t n_data,
@@ -824,9 +943,9 @@ int journal_file_verify(
         bool entry_seqnum_set = false, entry_monotonic_set = false, entry_realtime_set = false, found_main_entry_array = false;
         uint64_t n_objects = 0, n_entries = 0, n_data = 0, n_fields = 0, n_data_hash_tables = 0, n_field_hash_tables = 0, n_entry_arrays = 0, n_tags = 0;
         usec_t last_usec = 0;
-        _cleanup_close_ int data_fd = -1, entry_fd = -1, entry_array_fd = -1;
-        _cleanup_fclose_ FILE *data_fp = NULL, *entry_fp = NULL, *entry_array_fp = NULL;
-        MMapFileDescriptor *cache_data_fd = NULL, *cache_entry_fd = NULL, *cache_entry_array_fd = NULL;
+        _cleanup_close_ int data_fd = -1, entry_fd = -1, field_fd = -1, entry_array_fd = -1;
+        _cleanup_fclose_ FILE *data_fp = NULL, *entry_fp = NULL, *field_fp = NULL,  *entry_array_fp = NULL;
+        MMapFileDescriptor *cache_data_fd = NULL, *cache_entry_fd = NULL, *cache_field_fd = NULL, *cache_entry_array_fd = NULL;
         unsigned i;
         bool found_last = false;
         const char *tmp_dir = NULL;
@@ -868,6 +987,12 @@ int journal_file_verify(
                 goto fail;
         }
 
+        field_fd = open_tmpfile_unlinkable(tmp_dir, O_RDWR | O_CLOEXEC);
+        if (field_fd < 0) {
+                r = log_error_errno(field_fd, "Failed to create field file: %m");
+                goto fail;
+        }
+
         entry_array_fd = open_tmpfile_unlinkable(tmp_dir, O_RDWR | O_CLOEXEC);
         if (entry_array_fd < 0) {
                 r = log_error_errno(entry_array_fd,
@@ -888,6 +1013,12 @@ int journal_file_verify(
                 goto fail;
         }
 
+        cache_field_fd = mmap_cache_add_fd(m, field_fd, PROT_READ|PROT_WRITE);
+        if (!cache_field_fd) {
+                r = log_oom();
+                goto fail;
+        }
+
         cache_entry_array_fd = mmap_cache_add_fd(m, entry_array_fd, PROT_READ|PROT_WRITE);
         if (!cache_entry_array_fd) {
                 r = log_oom();
@@ -906,6 +1037,12 @@ int journal_file_verify(
                 goto fail;
         }
 
+        r = take_fdopen_unlocked(&field_fd, "w+", &field_fp);
+        if (r < 0) {
+                log_error_errno(r, "Failed to open field file stream: %m");
+                goto fail;
+        }
+
         r = take_fdopen_unlocked(&entry_array_fd, "w+", &entry_array_fp);
         if (r < 0) {
                 log_error_errno(r, "Failed to open entry array file stream: %m");
@@ -997,6 +1134,10 @@ int journal_file_verify(
                         break;
 
                 case OBJECT_FIELD:
+                        r = write_uint64(field_fp, p);
+                        if (r < 0)
+                                goto fail;
+
                         n_fields++;
                         break;
 
@@ -1327,6 +1468,11 @@ int journal_file_verify(
                 goto fail;
         }
 
+        if (fflush(field_fp) != 0) {
+                r = log_error_errno(errno, "Failed to flush data file stream: %m");
+                goto fail;
+        }
+
         if (fflush(entry_array_fp) != 0) {
                 r = log_error_errno(errno, "Failed to flush entry array file stream: %m");
                 goto fail;
@@ -1358,11 +1504,17 @@ int journal_file_verify(
         if (r < 0)
                 goto fail;
 
+        r = verify_field_hash_table(f,
+                                    cache_field_fd, n_fields);
+        if (r < 0)
+                goto fail;
+
         if (show_progress)
                 flush_progress();
 
         mmap_cache_fd_free(cache_data_fd);
         mmap_cache_fd_free(cache_entry_fd);
+        mmap_cache_fd_free(cache_field_fd);
         mmap_cache_fd_free(cache_entry_array_fd);
 
         if (first_contained)
@@ -1390,6 +1542,9 @@ fail:
         if (cache_entry_fd)
                 mmap_cache_fd_free(cache_entry_fd);
 
+        if (cache_field_fd)
+                mmap_cache_fd_free(cache_field_fd);
+
         if (cache_entry_array_fd)
                 mmap_cache_fd_free(cache_entry_array_fd);
 
